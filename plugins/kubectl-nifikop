#!/usr/bin/env python3
#
# Copyright 2019 Orange
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# 	You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# 	See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import json
import re
from subprocess import check_output, STDOUT, CalledProcessError
from os.path import basename
from random import shuffle
from itertools import groupby

def k_apply_with_input(input, error, *args):
    try:
        resource = json.loads(input)
        del resource["metadata"]["resourceVersion"]
        input = json.dumps(resource)
        check_output(["kubectl", "apply", "-f", "-"], stderr=STDOUT, input=str.encode(input))
    except CalledProcessError:
        die(error)

def k(*args):
    params = list(args)
    try:
        out = check_output(["kubectl"] + params, stderr=STDOUT)
        result = out.decode("utf-8")
        if result:
            if "-o" in " ".join(params):
                return result
            return [r.split() for r in result.split("\n")[1:-1]]
    except CalledProcessError:
        return []

def die(msg):
    print(f"{msg}. Have to stop here ...")
    sys.exit(1)

def pod_is_mandatory(name):
    if not name:
        die(f"Pod {name} not found")
    return name

def get_pods(args, option=[]):
    if args.prefix:
        pods = grep_pods(args.prefix, option)
    else:
        pods = grep_pods(pod_is_mandatory(args.pod),
                         option + [f"--field-selector=metadata.name={args.pod}"])
    if not pods:
        die(NO_PODS_FOUND)
    return pods

def grep_pods(prefix, option=[]):
    # We only look for running pods
    opt = option + ["--field-selector=status.phase=Running"]
    # Pods having an operation with the provided status or with no ongoing operation
    if not any(['operation-status' in o for o in option]):
        opt.append(NO_ONGOING_OP)
    grp = []
    for key, g in groupby(sorted(opt), lambda x:x[:x.index('=')+1]):
        grp.append(key + ','.join([opt[len(key):] for opt in g]))
    pods = [p[0] for p in k(*(["get", "pods"] + grp)) if prefix in p[0]]
    if not pods:
        die(NO_PODS_FOUND)
    return pods

def get_namespace():
    return k('config', 'view', '--minify', '--output', 'jsonpath={..namespace}') or 'default'

def set_pod_label(pod, operation, status="ToDo", argument=None):
    print(f"Set status of operation {operation} on pod {pod} to {status}")
    labels = [f"operation-name={operation}", f"operation-status={status}"]
    if argument:
        labels.append(f"operation-argument={argument}")
    k("label", "pods", pod, *labels, "--overwrite")

# Returns one running pod in the crd
def available_pod_in_crd(crd):
    pods = grep_pods(crd)
    crd_content = k("get", "cassandracluster", crd, "-o", "json")
    if not crd_content:
        die(f"crd {crd} not found")
    crd_content = json.loads(crd_content)["status"]["cassandraRackStatus"]
    busy_pods = set()
    for key in [k for k in crd_content.keys()
                if type(crd_content[k]) is dict and "podLastOperation" in crd_content[k].keys()]:
        pod_last_op = crd_content[key]["podLastOperation"]
        if "pods" in pod_last_op:
            busy_pods.update(set(pod_last_op["pods"]))
    # Let's not keep the default ascii sort
    shuffle(busy_pods)
    return next(p for p in pods if p not in busy_pods)

class Command(object):
    def __init__(self):
        plugin = basename(sys.argv[0])
        parser = argparse.ArgumentParser(
            description='Kubernetes plugin used to trigger operations',
            usage=f"""{plugin} <command> [<args>]
The available commands are:
   test
For more information you can run {plugin} <command> --help
""")
        parser.add_argument('command', help='Subcommand to run')
        args = parser.parse_args(sys.argv[1:2])
        self._command_must_exist(args.command, parser)
        print(f"Namespace {get_namespace()}")

        # Call function corresponding to the command passed
        getattr(self, args.command)()

    def _command_must_exist(self, operation, parser):
        if not hasattr(self, operation):
            print(f"Unrecognized operation {operation}")
            parser.print_help()
            exit(1)

if __name__ == '__main__':
    Command()

# sudo cp plugins/kubectl-nifikop /usr/local/bin/kubectl-nifikop && sudo chmod +x /usr/local/bin/kubectl-nifikop